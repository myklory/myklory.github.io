<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="TC275中断服务"><meta name="keywords" content="tricore,TC275"><meta name="author" content="Myklory"><meta name="copyright" content="Myklory"><title>TC275中断服务 | 年年有鱼</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#中断路由"><span class="toc-number">1.</span> <span class="toc-text"> 中断路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特点"><span class="toc-number">2.</span> <span class="toc-text"> 特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务请求节点"><span class="toc-number">3.</span> <span class="toc-text"> 服务请求节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#服务请求控制寄存器"><span class="toc-number">3.1.</span> <span class="toc-text"> 服务请求控制寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断控制单元icu"><span class="toc-number">4.</span> <span class="toc-text"> 中断控制单元ICU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#icu控制寄存器"><span class="toc-number">4.1.</span> <span class="toc-text"> ICU控制寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lwsr"><span class="toc-number">4.1.1.</span> <span class="toc-text"> LWSR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lasr"><span class="toc-number">4.1.2.</span> <span class="toc-text"> LASR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#错误捕获寄存器ecr"><span class="toc-number">4.1.3.</span> <span class="toc-text"> 错误捕获寄存器（ECR）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通用服务请求服务请求广播"><span class="toc-number">4.2.</span> <span class="toc-text"> 通用服务请求，服务请求广播</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通用服务请求gpsrxy"><span class="toc-number">5.</span> <span class="toc-text"> 通用服务请求（GPSRxy）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务请求广播寄存器srbx"><span class="toc-number">6.</span> <span class="toc-text"> 服务请求广播寄存器（SRBx）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统寄存器"><span class="toc-number">7.</span> <span class="toc-text"> 系统寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#仲裁程序"><span class="toc-number">8.</span> <span class="toc-text"> 仲裁程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tc27x中断系统的使用"><span class="toc-number">9.</span> <span class="toc-text"> TC27X中断系统的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu到icu的接口"><span class="toc-number">9.1.</span> <span class="toc-text"> CPU到ICU的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dma到icu的接口"><span class="toc-number">9.2.</span> <span class="toc-text"> DMA到ICU的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#软件引发的中断"><span class="toc-number">9.3.</span> <span class="toc-text"> 软件引发的中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#外部中断"><span class="toc-number">9.4.</span> <span class="toc-text"> 外部中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用例示例"><span class="toc-number">10.</span> <span class="toc-text"> 用例示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#中断处理程序示例"><span class="toc-number">10.1.</span> <span class="toc-text"> 中断处理程序示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模块实现"><span class="toc-number">11.</span> <span class="toc-text"> 模块实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tc27x模块服务请求触发器到srn的映射"><span class="toc-number">11.1.</span> <span class="toc-text"> TC27x模块服务请求触发器到SRN的映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务请求控制寄存器的映射"><span class="toc-number">11.2.</span> <span class="toc-text"> 服务请求控制寄存器的映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与调试复位有关的中断"><span class="toc-number">11.3.</span> <span class="toc-text"> 与调试复位有关的中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务请求触发信号的定时特性"><span class="toc-number">11.4.</span> <span class="toc-text"> 服务请求触发信号的定时特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断路由器系统和模块寄存器"><span class="toc-number">12.</span> <span class="toc-text"> 中断路由器系统和模块寄存器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#硬件中断的实现"><span class="toc-number"></span> <span class="toc-text"> 硬件中断的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#illd的软件中断实现"><span class="toc-number"></span> <span class="toc-text"> iLLD的软件中断实现</span></a></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Myklory</div><div class="author-info__description text-center">总有一天，我们会感谢我们曾经付出的努力！</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">6</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/ox/wallhaven-oxv8pm.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">年年有鱼</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">TC275中断服务</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/tricore/">tricore</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">6.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 23 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="中断路由"><a class="markdownIt-Anchor" href="#中断路由"></a> 中断路由</h2>
<p>中断路由调度由外部，内部和软件引发的到CPU和DMA的中断请求。</p>
<p>中断请求可以由CPU和DMA提供中断服务。在这里统一称中断请求为服务请求。</p>
<p>TC275中的中断系统在中断路由模块中实现，该模块包括服务请求节点（SRN），中断控制单（ICU）以及用于软件开发支持的其它功能。</p>
<p>在图16-1中,每个可生成服务请求的TC27X模块都链接到中断路由模块中的一个或多个服务请求节点（SRN）。中断路由还包括几个通用服务请求节点。可用于软件（SW）触发的服务请求。</p>
<p>每个SRN都包含一个服务请求控制寄存器（SRC），用于配置有关例如优先级的服务请求，并映射到中断服务提供者（CPU或DMA）。</p>
<p>每个SRN连接到中断路由器模块中的所有ICU，其中SRN的控制寄存器设置定义了目标服务提供者和服务请求的优先级。每个ICU处理来自映射到ICU的SRN的竞争服务请求之间的中断仲裁。</p>
<p>每个ICU连接到一个服务提供者（CPU或DMA模块），在该服务提供者中，ICU提供仲裁回合的有效命中服务请求/ SRN，并且服务提供者向ICU回传在何时以及正在处理哪个服务请求时的信号。</p>
<p><img src="TC27x_Interrupt_System.png" alt="TC27x Interrupt System" /></p>
<h2 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h2>
<ul>
<li>中断系统最多支持512/1024个服务请求</li>
<li>每个ICU最多支持255个服务请求优先级1个）/服务提供者</li>
<li>最多支持16个ICU /服务提供者</li>
<li>每个CPU和DMA模块均带有专用ICU</li>
<li>独立于其他ICU的ICU服务请求仲裁</li>
<li>低延迟仲裁-三个/四个时钟2），从收到服务请求到将其发送给服务提供者</li>
<li>每个服务请求都有专用的服务请求节点（SRN）</li>
<li>每个SRN具有可编程的8位优先级向量1）</li>
<li>每个SRN都可以映射到已实现的ICU /服务提供者之一</li>
<li>在配置的服务提供者确认中断后，硬件会自动清除SRN</li>
<li>中断系统完整性支持</li>
<li>每个CPU四个通用服务请求（GPSR）可用作软件中断（未分配给外围设备或外部中断）</li>
<li>向多个服务提供者同时发出通用服务请求（软件中断）信号的机制（服务请求广播寄存器，SRB）</li>
<li>服务请求的优先级依赖屏蔽（对于CPU，CPU中包含的相关控制寄存器）</li>
<li>具有滤波器模式和触发模式的外部中断（例如下降沿，上升沿，高电平或低电平）。可以在运行时配置模式</li>
<li>CPU唤醒支持（如果CPUx处于IDLE状态，则向SCU发送对CPUx的服务请求信号以唤醒CPUx）</li>
</ul>
<h2 id="服务请求节点"><a class="markdownIt-Anchor" href="#服务请求节点"></a> 服务请求节点</h2>
<p>中断路由器模块内的每个服务请求节点（SRN）均包含一个服务请求控制（SRC）寄存器和接口逻辑，该寄存器将其连接至中断路由器模块外部的触发单元以及中断路由器内部的中断仲裁总线（见：图16-1 ）</p>
<h3 id="服务请求控制寄存器"><a class="markdownIt-Anchor" href="#服务请求控制寄存器"></a> 服务请求控制寄存器</h3>
<p>中断路由器模块中的所有服务请求控制寄存器都具有相同的格式。通常，这些寄存器包含：</p>
<ul>
<li>启用/禁用信息</li>
<li>服务请求设置位和服务请求清除位</li>
<li>服务请求优先级向量（8位）</li>
<li>服务提供商的目的地</li>
<li>服务请求状态位</li>
<li>软件启动的服务请求设置和重置位</li>
<li>完整性错误已发送至安全监控单元（SMU）</li>
<li>中断粘滞和溢出位</li>
</ul>
<p>除了由相关的触发单元通过硬件激活之外，每个SRN还可以通过两个软件启动的服务请求控制位由软件设置或重置。</p>
<p>本章中的描述描述了TC27x的所有服务请求控制寄存器。在模块章节的相应部分中提供了有关外围模块中断功能的信息，例如使能或请求标志。（略）</p>
<p>值得注意的几个位是中断服务提供者TOS，中断使能标志SRE，中断优先级编号SRPN。</p>
<p><strong>中断请求优先级编号（SRPN）</strong></p>
<p>对于中断服务提供者是一个CPU：<br />
ISR通过每个CPU中的中断向量表与服务请求优先级编号相关联。这意味着CPU中断向量表按优先级顺序排序。这不同于传统的中断CPU体系结构，在传统的中断CPU体系结构中，其中断向量表由中断源排序。CPU中断向量表允许单个外设具有用于不同目的的多个优先级。</p>
<p>注意：对于CPU，SRPN值为0000 H是一个特殊值，并且不得用于映射到CPU的服务请求。</p>
<p>注意：TC1.6E和TC1.6P CPU提供了灵活的中断表对齐方式，配置了8字节或32字节的向量间隔。请 另请参见“CPU”一章。</p>
<p>对于中断服务提供者是DMA：</p>
<p>完整的SRPN编号用于DMA模块的服务请求仲裁。在模块内，DMA通道通过SRPN的SRPN LSB与服务请求优先级编号相关联。</p>
<p>仅SRPN编号0 … max_channel_number将导致相关DMA通道的触发。SRPN编号&gt; max_channel编号不会导致DMA通道触发或任何其他信号。</p>
<p>例子：</p>
<ul>
<li>对于16通道DMA模块，SRPN号OOH将触发通道0，07H将触发通道7。所有SRPN&gt; 0FH都不会导致通道触发。</li>
<li>对于64通道DMA模块，SRPN编号00H将触发通道0，17H将触发通道23和3FH。将触发通道64。所有SRPN&gt; 3FH都不会导致通道触发。</li>
</ul>
<h2 id="中断控制单元icu"><a class="markdownIt-Anchor" href="#中断控制单元icu"></a> 中断控制单元ICU</h2>
<p>中断路由器模块每个服务提供商（CPU和DMA模块）包括一个ICU，其中每个ICU与一个服务提供商相关。可以通过SRN SRCx.TOS寄存器位字段将SRN映射到ICU之一（见：图16-1 ）。</p>
<p>中断控制单元（ICU）：</p>
<ul>
<li>管理来自映射到ICU的SRN的竞争服务请求之间的仲裁</li>
<li>向服务提供商提供仲裁回合的胜者</li>
<li>从服务提供商接收接受了哪个服务请求的信息</li>
<li>检查接受的服务请求信息（ECC检查）</li>
<li>将完整性错误通知安全监视单元（SMU）</li>
<li>管理清除相关SRN中已确认的服务请求</li>
</ul>
<p>注意：在当前实现中，ECC代码仅用于错误检测。检测到的错误会报告给SMU，但不会纠正。</p>
<h3 id="icu控制寄存器"><a class="markdownIt-Anchor" href="#icu控制寄存器"></a> ICU控制寄存器</h3>
<p>每个ICU包含两个控制寄存器：</p>
<ul>
<li>最新的中标服务请求寄存器（LWSR）提供有关上一服务请求仲裁回合的中标者的信息</li>
<li>上次确认的服务请求寄存器（LASR）提供有关服务提供者接受的上一个服务请求的信息</li>
</ul>
<h4 id="lwsr"><a class="markdownIt-Anchor" href="#lwsr"></a> LWSR</h4>
<p>LWSR存储了最后一次命中的中断服务请求信息。</p>
<p>STAT：指定LWSR是否有效，即是否有命中的叫断服务请求</p>
<p>PN：优先级</p>
<p>ID：SRN的ID</p>
<h4 id="lasr"><a class="markdownIt-Anchor" href="#lasr"></a> LASR</h4>
<p>LASR存储了最后一次确认的中断服务请求，除没有STAT外与LWSR一致。</p>
<h4 id="错误捕获寄存器ecr"><a class="markdownIt-Anchor" href="#错误捕获寄存器ecr"></a> 错误捕获寄存器（ECR）</h4>
<p>当ICU检测到ECC错误时，错误捕获寄存器将捕获最后确认服务请求（LASR）寄存器的内容。ECR始终显示检测到ECC错误的最后一个ECR内容。软件可以通过写入ECR清除ECR内容。错误状态（STAT）和错误溢出（EOV）位可用作错误处理机制，并指示错误信息丢失了。</p>
<p>如果SW清除了ECR.EOV，则必须与ECR.STAT一起清除ECR.EOV。如果在与ECR.EOV并行的同时检测到新错误，则清除ECR.STAT时由硬件再次设置ECR.EOV。</p>
<p>注意：在当前实现中，ECC代码仅用于错误检测。检测到的错误会报告给SMU，但不会纠正。</p>
<h3 id="通用服务请求服务请求广播"><a class="markdownIt-Anchor" href="#通用服务请求服务请求广播"></a> 通用服务请求，服务请求广播</h3>
<p>中断路由器模块提供了多组通用服务请求（GPSR），以及一种通过软件并行触发GPSR组的多个服务请求的机制。GPSR可用作软件中断。</p>
<p><img src="GPSR.png" alt="GPSR" /></p>
<h2 id="通用服务请求gpsrxy"><a class="markdownIt-Anchor" href="#通用服务请求gpsrxy"></a> 通用服务请求（GPSRxy）</h2>
<p>中断路由器模块提供多组通用服务请求：</p>
<ul>
<li>每个通用服务请求组都包含四个可用作软件中断的服务请求节点</li>
<li>通用服务请求可以通过相关的服务请求控制寄存器SRC_GPSRxy 进行配置和控制。</li>
<li>GPSR未映射到模块服务请求触发器，因此只能用于软件触发器</li>
<li>通用服务请求xy只能通过将T写入相关的SRC_GPSRxy.SETR 位或将1写入相关的服务请求广播寄存器位SRBx[y] 来触发。</li>
</ul>
<h2 id="服务请求广播寄存器srbx"><a class="markdownIt-Anchor" href="#服务请求广播寄存器srbx"></a> 服务请求广播寄存器（SRBx）</h2>
<p>每个通用服务请求组（GPSRxy）都实现了一个服务请求广播寄存器（SRBx）4））。</p>
<p>服务请求广播寄存器x可用于并行触发SRC_GPSRx 1 ）组内的多个服务请求。</p>
<ul>
<li>SRBx始终读为0</li>
<li>将1写入SRBx[y]会触发服务请求GPXRxy（y = 3：0）</li>
<li>将1写入SRBx[31：4]无效。</li>
</ul>
<h2 id="系统寄存器"><a class="markdownIt-Anchor" href="#系统寄存器"></a> 系统寄存器</h2>
<p>系统寄存器包括了时钟CLC，寄存器访问保护（ACCEN1/0）等。</p>
<h2 id="仲裁程序"><a class="markdownIt-Anchor" href="#仲裁程序"></a> 仲裁程序</h2>
<p>中断模块中的每个ICU都有自己的中断总线。通过经由SRC.TOS位字段设置将每个服务请求节点（SRN）映射到相关的ICU /中断总线，可以将其定向到一个服务提供者。</p>
<p><img src="Interrupt_System.png" alt="Interrupt System" /></p>
<p>对于第一个未决服务请求，中断总线正在启动第一个仲裁过程。只要至少一个服务请求未决，就重复在一个中断总线上进行仲裁过程。相关的中断控制单元提供赢得了最后仲裁程序的服务请求。</p>
<p>这意味着：当ICU向服务提供商提供服务请求，并且有更高优先级的新服务请求进入时，ICU将在下一个仲裁过程之后提供新服务请求。</p>
<p>TC27x中实现的仲裁过程使用3个系统外设总线时钟周期来确定优先级最高的待决服务请求SRPN。实现的确切编号在“模块实现”一章中进行了描述。</p>
<p>在仲裁过程中，中断总线比较所有未决服务请求节点的SRC.SRPN位字段，这些位通过SRC.TOS设置映射到此中断总线。</p>
<p>在仲裁过程中，优先级最高的挂起服务请求被标识为获胜者，相关的SRN服务请求控制寄存器位字段值SRPN，ECC和SRN的索引将提供给ICU。ICU将这些（SRPN，ECC，SRN索引）提供给服务提供商。当ICU通过确认从服务提供商处获取这些信息时，会进行ECC检查。ECC检查使用接收到的值完成：ECC，SRPN，SRN索引号，假定为1的SRE位（启用SRN）和ICU的TOS编号。</p>
<p>中断路由器模块将检测到的错误通知安全管理单元（SMU中的一位，覆盖所有SRN和ICU的错误）。</p>
<p>注意：在当前实现中，ECC代码仅用于错误检测。检测到的错误会报告给SMU，但不会纠正。</p>
<p>仲裁过程略。</p>
<h2 id="tc27x中断系统的使用"><a class="markdownIt-Anchor" href="#tc27x中断系统的使用"></a> TC27X中断系统的使用</h2>
<p>以下各节简要介绍了到中断路由器ICU的服务提供商接口。</p>
<p>注意：中断路由器中的所有ICU子模块都具有相同的功能。</p>
<h3 id="cpu到icu的接口"><a class="markdownIt-Anchor" href="#cpu到icu的接口"></a> CPU到ICU的接口</h3>
<p>每个CPU具有一个接口，该接口连接到中断路由器模块的一个ICU。CPU ICU接口由一个寄存器集组成，该寄存器集负责接管ICU提供的服务请求信息（SRPN，SRN索引，ECC）。当CPU确认提供的服务请求时，这些信息将发送回ICU。</p>
<p>CPU ICU接口包含一个中断控制寄存器（ICR），该寄存器保存当前的CPU优先级号（CCPN），全局中断允许/禁止位（IE）和未决的中断优先级号（PIPN）。有关CPU ICU接口和CPU中断处理的更多详细信息，请参见“CPU”一章。</p>
<h3 id="dma到icu的接口"><a class="markdownIt-Anchor" href="#dma到icu的接口"></a> DMA到ICU的接口</h3>
<p>DMA模块具有一个接口，该接口连接到中断路由器模块的一个ICU。</p>
<p>DMA接管ICU的服务请求信息，在内部触发寻址的信道，并立即将其确认给ICU，在此清除相关的SRN。</p>
<p>DMA到ICU的接口由一个寄存器集组成，该寄存器集负责接管ICU提供的服务请求信息（SRPN，SRN索引，ECC）。DMA在下一个时钟周期将它们发送回ICU，并进行确认。</p>
<p>DMA通道优先级方案与中断系统的方案相同：较高的SRPN编号-&gt;较高的服务请求优先级，较高的DMA通道编号-&gt; DMA通道的较高优先级，其中通道0在DMA中的优先级最低。</p>
<h3 id="软件引发的中断"><a class="markdownIt-Anchor" href="#软件引发的中断"></a> 软件引发的中断</h3>
<p>软件可以通过写入其服务请求控制寄存器来设置任何SRN中的服务请求位（SRR）。因此，软件可以发起由与硬件发起的服务请求相同的机制处理的服务请求。</p>
<p>在SRN中将SRR位置1之后，就无法在软件启动的服务请求和硬件启动的服务请求之间进行区分。因此，软件应仅使用未用于硬件启动的服务请求的SRN和中断优先级编号。</p>
<p>TC27x每个CPU包含一组通用服务请求SRN，这些SRN支持软件启动的中断。每个已实现的TriCore CPU一组，每组包括四个SRN。这些SRN未连接到内部或外部硬件触发信号，只能用作软件中断/软件启动的服务请求。这些SRN称为通用服务请求节点（SRC_GPSRxy，x =组号，y = 0-3）。</p>
<p>另外，可以使用任何其他未使用的SRN来生成软件中断。</p>
<h3 id="外部中断"><a class="markdownIt-Anchor" href="#外部中断"></a> 外部中断</h3>
<p>保留了四个SRN（lnt_SCUSRC [3：0]）来处理外部中断。能够产生中断请求的外部GPIO端口输入信号（边沿/电平触发，门控等）的设置在外部请求单元（ERU）中进行控制。在SCU章节中详细介绍了ERU功能。</p>
<h2 id="用例示例"><a class="markdownIt-Anchor" href="#用例示例"></a> 用例示例</h2>
<p>本节显示了中断系统的用例和OTGS的用例。</p>
<h3 id="中断处理程序示例"><a class="markdownIt-Anchor" href="#中断处理程序示例"></a> 中断处理程序示例</h3>
<p>当TriCore接受中断时，中断向量表的入口地址由基本中断向量表指针TriCore寄存器BIV和该中断的优先级编号（PIPN）计算。TriCore TC1.6P和TC1.6E架构提供了将每个条目的向量间距配置为32字节（请参见下图a（图16-6 ）或8字节（请参见下图b（图16-6 ））的可能性。作为第三种选择，可以通过屏蔽PIPN将向量表简化为单个条目（请参见下图c（图16-6 ））。</p>
<p><img src="Interrupt_Vector_Table_Address_Calculation.png" alt="Interrupt Vector Table Address Calculation" /></p>
<p>通过命令把中断向量表写入BIV（Base Interrupt Vector Table Pointer）中（这里是c的写入）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__mtcr(BIV,<span class="number">0x80000001</span> | <span class="number">0xFF</span>&lt;&lt;<span class="number">3</span>); <span class="comment">// move to core register BIV</span></span><br></pre></td></tr></table></figure>
<p><strong>初始化和安装中断的步骤描述：</strong></p>
<ul>
<li>（第1行）定义ISR指针数组。最高 可能有255个中断。</li>
<li>（第2行）定义指向isr_pointer_array起点的指针。</li>
<li>（第3行）开始执行函数interruptHandlerInstall。该函数将中断安装在数组中。必要的信息是中断优先级和ISR入口地址。</li>
<li>（第4行）此行将ISR条目地址存储在阵列中。</li>
<li>（第5和6行）此函数分支到特定的中断例程，并在中断发生后立即被调用。</li>
<li>（第7行）在处理完ISR之后，此行给出了return命令。</li>
</ul>
<p>初始化和安装中断的C代码示例：</p>
<ul>
<li>（1）void（* isr_pointer_array [256]）（void）;</li>
<li>（2）void（** isr）（void）= isr_pointer_array;</li>
<li>（3）void interruptHandlerInstall（long int SRprio，long int addr）{</li>
<li>（4）* isr_pointer_array [SRprio] = addr;<br />
}</li>
<li>（5）void interruptHandler（void）{</li>
<li>（6）isr [__ mfcr（ICR）＆0xFF]（）;</li>
<li>（7）asm（“ rfe”）; //从事件返回</li>
</ul>
<p>中断入口地址存储在数据数组中，而不是将值编码到指令中。函数interruptHandlerInstall可以在该数组中组织中断的安装（请参见模块中此中断处理程序的应用，例如STM章中的用例示例）。这种向量表生成有时提供比8字节配置更灵活的方式，并且不需要对中断的任何特定编译器支持。</p>
<p>注意：在中断发生之前，必须全局启用中断系统。中断控制寄存器（ICR）保留全局中断使能位（<a href="http://ICR.IE" target="_blank" rel="noopener">ICR.IE</a>）启用CPU服务请求系统。大多数编译器支持该属性（或类似属性）：</p>
<p>_enable（）;</p>
<p>设置此位。（有关更多详细信息，另请参见《体系结构手册》）</p>
<h2 id="模块实现"><a class="markdownIt-Anchor" href="#模块实现"></a> 模块实现</h2>
<h3 id="tc27x模块服务请求触发器到srn的映射"><a class="markdownIt-Anchor" href="#tc27x模块服务请求触发器到srn的映射"></a> TC27x模块服务请求触发器到SRN的映射</h3>
<p>所有TC27x模块服务请求都映射到中断路由器中的一个服务请求节点。</p>
<p>每个SRN在中断路由器模块中都有一个唯一的SRN索引号。</p>
<p>中断路由器模块具有一个511/1024中断触发输入向量，其中中断触发输入向量位[x]与SRN的序号为x的SRN相关。这意味着中断触发输入向量位[x]上的触发脉冲将触发SRN [x]。</p>
<p><img src="Mapping_of_Module_Interrupt_Trigger_to_SRN.png" alt="Mapping of Module Interrupt Trigger to SRN" /></p>
<h3 id="服务请求控制寄存器的映射"><a class="markdownIt-Anchor" href="#服务请求控制寄存器的映射"></a> 服务请求控制寄存器的映射</h3>
<p>与一个模块实例相关的SRC寄存器的地址在整个AURIX系列中都是相同的（例如SPI0的中断）。</p>
<p>每个SRN在中断路由器模块中都有一个唯一的SRN索引号。</p>
<p>每个AURIX设备的已实现SRN的数量与设备功能集相匹配。中断路由器模块中的所有SRN都有连续的索引号（例如：如果实现256个SRN，则索引号为0-255）。每个SRN在中断路由器模块中都有一个唯一的SRN索引号。</p>
<p>例：</p>
<p>在具有许多模块/模块实例的高端设备中，SPI0中断可能被映射到索引号为180至185的SRN，可以通过地址偏移量0x2F0至0x2F5访问相关的SRC。</p>
<p>为了满足这两个要求（所有AURIX设备中与SPI0相关的SRC的地址相同，但在具有连续索引号的小型系列设备中减少SRN的数量），中断路由器模块包括一个地址映射外壳（图16-8 ）。例如上述例子中的SPI0的固定SRC地址重新映射到所述中断路由器模块中的SRN。</p>
<p><img src="Mapping_of_SRC_System_Address_to_SRNs.png" alt="Mapping of SRC System Address to SRNs" /></p>
<h3 id="与调试复位有关的中断"><a class="markdownIt-Anchor" href="#与调试复位有关的中断"></a> 与调试复位有关的中断</h3>
<p>为了进行软件调试，AURIX设备需要一些仅与“调试重置”相关的服务请求节点。在非调试复位（例如，应用程序复位）的情况下，这些SRN会保留其SRC寄存器内容和未决服务请求状态。与其他与调试重置相关的调试逻辑（例如，断点逻辑）结合使用，这可使客户SW调试导致应用程序重置以及在应用程序重置之后的情况。</p>
<h3 id="服务请求触发信号的定时特性"><a class="markdownIt-Anchor" href="#服务请求触发信号的定时特性"></a> 服务请求触发信号的定时特性</h3>
<p>中断路由器以系统外围总线（SPB）时钟为时钟</p>
<p>TC27x模块中断/服务请​​求触发信号向IR的规则：</p>
<ul>
<li>触发信号必须与SPB时钟同步</li>
<li>IR触发输入对边沿敏感（正时钟边沿）</li>
<li>最小触发信号脉冲。一个SPB时钟周期的高长度，高脉冲长度可以&gt; 1个SPB时钟周期</li>
<li>调试相关的触发信号脉冲应由相关的TC27x模块保持高电平，直到处理了触发为止</li>
</ul>
<h2 id="中断路由器系统和模块寄存器"><a class="markdownIt-Anchor" href="#中断路由器系统和模块寄存器"></a> 中断路由器系统和模块寄存器</h2>
<h1 id="硬件中断的实现"><a class="markdownIt-Anchor" href="#硬件中断的实现"></a> 硬件中断的实现</h1>
<p>上面都是手册上理论的东西，我们要自己实现软件中断和硬件中断应该怎么办呢？</p>
<p>TC275支持255个优先级，每个优先级即为对应的中断向量号。</p>
<p>0优先级的中断不使用。</p>
<p>首先是BIV(Base Interrupt Vector Table Pointer)寄存器中存储了中断向量表的起始地址。BIV寄存器中的VSS(Vector Spacing Select)位指定了BIV和ICR寄存器中PIPN位中断优先级计算中断向量表偏移的方法。</p>
<p><img src="Interrupt_Vector_Table_Address_Calculation.png" alt="Interrupt Vector Table Address Calculation" /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(BIV.VSS == <span class="number">0</span>)</span><br><span class="line">    addr = ( BIV | (ICR.PIPN &lt;&lt; <span class="number">5</span>) ); <span class="comment">//每次入口移动32字节</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    addr = ( BIV | (ICR.PIPN &lt;&lt; <span class="number">3</span>) ); <span class="comment">//每次入口移动8字节</span></span><br></pre></td></tr></table></figure>
<p>同时，根据上面公式也可以反推出中断向量表中每个中断处理函数的空间分别为32字节和8字节。可以把PIPN分别设为0和1进行测试，刚好是32字节和8字节的偏移。</p>
<p>即和下图一致：</p>
<p><img src="Interrupt_Vector_Table.png" alt="Interrupt Vector Table" /></p>
<p>所有的中断处理函数都需要在这32字节或8字节中完成。</p>
<p>我们也可以手动设置BIV[5:12]或者BIV[3:9]的值来灵活处理每一个优先级中断的入口地址，例如ILLD中使用的软件中断就把所有优先级的入口地址都定位到了第255优先级的入口地址。</p>
<p>了解了BIV到中断处理函数的转换和中断处理函数的大小，就可以配置和生成中断向量表。</p>
<p><strong>HIGHTEC硬件中断的示例：</strong></p>
<p>先定义中断服务函数的结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IntIsr_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*Int_Handle)(); <span class="comment">/* 中断服务函数指针 */</span></span><br><span class="line">    <span class="keyword">int</span> arg;              <span class="comment">/* 参数 */</span></span><br><span class="line">&#125;IntIsr;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_INTS 32 <span class="comment">/* 定义32个中断 */</span></span></span><br><span class="line"></span><br><span class="line">IntIsr IntTable[MAX_INTS];  <span class="comment">/* 中断服务函数数组 */</span></span><br></pre></td></tr></table></figure>
<p>在HIGHTEC编译器中，中断向量表是由下面的代码定义和生成的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* section .inttab start */</span></span><br><span class="line">__asm ( <span class="string">".section .hwtab, \"ax\", @progbits\n"</span> <span class="comment">/* 定义了节.inttab开始 */</span></span><br><span class="line">        <span class="string">".align 13\n"</span>                           <span class="comment">/* 按照2^13次方对齐，即8K对齐 */</span></span><br><span class="line">        <span class="string">".global TriCore_int_table\n"</span>           <span class="comment">/* 定义一个标签，这个标签会在设置BIV时使用，即中断向量表的起始地址为TriCore_int_table */</span></span><br><span class="line">        <span class="string">"TriCore_int_table:\n"</span>     <span class="comment">/* 代码开始 */</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">__asm (	<span class="string">"debug		# int 0\n"</span> <span class="comment">/* 中断向量0是不使用的，如果进入这个中断，整个程序挂起 */</span></span><br><span class="line">		<span class="string">".align 5\n"</span>    <span class="comment">/* 2^5对齐，即32字节对齐 */</span></span><br><span class="line">	  );</span><br><span class="line"><span class="comment">/* 定义每个中断向量的入口，参数i为中断向量号 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_INT(i)							\</span></span><br><span class="line">    <span class="comment">/* 定义每一个中断向量起始的标签，如__interrupt_0 */</span> \</span><br><span class="line">	__asm (<span class="string">".global __interrupt_"</span> #i);			\</span><br><span class="line">	__asm (<span class="string">"__interrupt_"</span> #i <span class="string">":"</span>);				\</span><br><span class="line">    <span class="comment">/* bisr指令用来保存低级上下文，和SVLCX指令一样，同时设置ICR.IE位为1，允许中断 */</span>\</span><br><span class="line">	__asm (<span class="string">"bisr "</span> #i);							\</span><br><span class="line">    <span class="comment">/* 将中断服务函数地址的放入A14中,参数放入D4中 */</span>\</span><br><span class="line">	__asm (<span class="string">"movh.a %a15,hi:IntTable+8*"</span>#i);		\</span><br><span class="line">	__asm (<span class="string">"lea %a15,[%a15]lo:IntTable+8*"</span>#i);	\</span><br><span class="line">	__asm (<span class="string">"ld.a %a14,[%a15+]"</span>);				\</span><br><span class="line">	__asm (<span class="string">"ld.w %d4,[%a15]"</span>);					\</span><br><span class="line">    <span class="comment">/* 调用中断服务函数 */</span>\</span><br><span class="line">	__asm (<span class="string">"calli %a14"</span>);						\</span><br><span class="line">    <span class="comment">/* 恢复低级上下文 */</span>\</span><br><span class="line">	__asm (<span class="string">"rslcx"</span>);							\</span><br><span class="line">    <span class="comment">/* 执行返回指令 */</span>\</span><br><span class="line">	__asm (<span class="string">"rfe"</span>);								\</span><br><span class="line">    <span class="comment">/* 代码32字节对齐 */</span>\</span><br><span class="line">	__asm (<span class="string">".align 5"</span>)</span><br><span class="line"></span><br><span class="line">DEFINE_INT(<span class="number">1</span>); <span class="comment">//定义中断向量1</span></span><br></pre></td></tr></table></figure>
<p>上面的代码把每一个中断向量都定义在了输入节.hwtab中，并且定义了中断向量表的起始地址TriCore_int_table，使用这个地址初始化BIV。</p>
<p>初始化BIV</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 由于上面的中断向量表代码会编译到输入节.hwtab中，其它的函数代码要链接到.text代码节中，这里又开始代码节 */</span></span><br><span class="line">__asm(<span class="string">".text"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义默认的中断服务函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">default_int_handle</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断向量表起始地址 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> TriCore_int_table[];</span><br><span class="line"><span class="comment">/* 初始化中断向量表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Vectable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vecno;</span><br><span class="line">    unlock_wdtcon(); <span class="comment">/* 解锁寄存器保护 */</span></span><br><span class="line">    <span class="comment">/* 初始化BIV */</span></span><br><span class="line">    <span class="function">__asm <span class="title">volatile</span> <span class="params">(<span class="string">"mtcr $biv,%0"</span> : : <span class="string">"d"</span> (TriCore_int_table))</span></span>;</span><br><span class="line">    lock_wdtcon(); <span class="comment">/* 保护寄存器 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化中断服务函数 */</span></span><br><span class="line">    <span class="keyword">for</span> (vecno = <span class="number">0</span>; vecno &lt; MAX_INTS; vecno++)</span><br><span class="line">    &#123;</span><br><span class="line">        IntTable[vecno].Int_Handle = default_int_handle;</span><br><span class="line">        IntTable[vecno].arg = vecno;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在BIV的地址指向了TriCore_int_table，根据引起中断的优先级，就可以计算出中断向量的起始地址，在这个地址执行中断服务函数。</p>
<p>定义中断服务函数安装函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  中断服务函数安装</span></span><br><span class="line"><span class="comment"> * @note   </span></span><br><span class="line"><span class="comment"> * @param  intno: 中断优先级</span></span><br><span class="line"><span class="comment"> * @param  (*inthandler): 中断服务函数指针 </span></span><br><span class="line"><span class="comment"> * @retval </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Install_Isr</span><span class="params">(<span class="keyword">int</span> intno, <span class="keyword">void</span> (*inthandler)(<span class="keyword">int</span>), <span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((intno &lt; <span class="number">0</span>) || (intno &gt;= MAX_INTS))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	Cdisptab[intno].hnd_handler = inthandler;</span><br><span class="line">	Cdisptab[intno].hnd_arg = arg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Enable_Interrupt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，整个中断向量表都初始化完成了。接下来就是要设置对应的服务请求节点来响应中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> reload_value = <span class="number">100000</span>; <span class="comment">/* 随便一个测试值 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stm0_Isr</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MODULE_STM0.CMP[<span class="number">0</span>].U = MODULE_STM0.TIM0.U + reload_value;</span><br><span class="line">    MODULE_STM0.ICR.B.CMP0EN = <span class="number">1</span>; <span class="comment">/* 开始定时器 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 安装中断服务函数 */</span></span><br><span class="line">    Install_Isr(<span class="number">1</span>, Stm0_Isr, <span class="number">0xFE</span>);</span><br><span class="line">    <span class="comment">/* 设置中断服务请求源 */</span></span><br><span class="line">    SRC_STM0SR0.B.SRPN = <span class="number">1</span>; <span class="comment">/* 设置优先级为1， 与上面保持一致 */</span></span><br><span class="line">    SRC_STM0SR0.B.TOS = <span class="number">0</span>; <span class="comment">/* 设置为CPU0响应中断 */</span></span><br><span class="line">    SRC_STM0SR0.B.SRE = <span class="number">1</span>; <span class="comment">/* 允许中断 */</span></span><br><span class="line">    <span class="comment">/* 设置定时器 */</span></span><br><span class="line">    MODULE_STM0.CMP[<span class="number">0</span>].U = MODULE_STM0.TIM0.U + reload_value;</span><br><span class="line">	MODULE_STM0.CMCON.B.MSIZE0 = <span class="number">31</span>;	<span class="comment">/* use bits 31:0 for compare */</span></span><br><span class="line">    MODULE_STM0.ISCR.U = (IFX_STM_ISCR_CMP0IRR_MSK &lt;&lt; IFX_STM_ISCR_CMP0IRR_OFF);</span><br><span class="line">	MODULE_STM0.ICR.B.CMP0EN = <span class="number">1</span>; <span class="comment">/* 开始定时器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在SRC相关的寄存器中，设置优先级SRPN，中断服务提供者TOS，和中断使能开关SRE，即可等待信号触发中断。</p>
<p>以上就是HIGHTEC示例代码的硬件中断实现方式。</p>
<p><strong>iLLD硬件中断实现方式</strong></p>
<p>iLLD把中断向量表的每一个中断向量都在链接文件中定义了一个输入和输出节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.inttab_tc0_000 (LCF_INTVEC0_START + <span class="number">0x0</span>) : &#123; . = ALIGN(<span class="number">8</span>) ;  KEEP (*(.intvec_tc0_0)); &#125; &gt; pfls0</span><br><span class="line">.inttab_tc0_001 (LCF_INTVEC0_START + <span class="number">0x20</span>) : &#123; . = ALIGN(<span class="number">8</span>) ;  KEEP (*(.intvec_tc0_1)); &#125; &gt; pfls0</span><br><span class="line">...</span><br><span class="line">.inttab_tc0_0FE (LCF_INTVEC0_START + <span class="number">0x1FC0</span>) : &#123; . = ALIGN(<span class="number">8</span>) ;  KEEP (*(.intvec_tc0_254)); &#125; &gt; pfls0</span><br><span class="line">.inttab_tc0_0FF (LCF_INTVEC0_START + <span class="number">0x1FE0</span>) : &#123; . = ALIGN(<span class="number">8</span>) ;  KEEP (*(.intvec_tc0_255)); &#125; &gt; pfls0</span><br><span class="line">__INTTAB_CPU0 = LCF_INTVEC0_START;</span><br></pre></td></tr></table></figure>
<p>一共255个中断向量。<br />
中断服务代码是在输入节.intvec_tc0_000到.intvec_tc0_255中定义的。代码在CompilerGnuc.h中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IFX_INTERRUPT_INTERNAL(isr, vectabNum, prio) \</span></span><br><span class="line">__asm__ (<span class="string">".ifndef .intr.entry.include                        \n"</span>\</span><br><span class="line">		<span class="string">".altmacro                                           \n"</span>\</span><br><span class="line">		<span class="string">".macro .int_entry.2 intEntryLabel, name # define the section and inttab entry code \n"</span>\</span><br><span class="line">        <span class="string">"	.pushsection .\\intEntryLabel,\"ax\",@progbits   \n"</span>\</span><br><span class="line">        <span class="string">"	__\\intEntryLabel :                              \n"</span>\</span><br><span class="line">        <span class="string">"		svlcx                                        \n"</span>\</span><br><span class="line">        <span class="string">"		movh.a  %a14, hi:\\name                      \n"</span>\</span><br><span class="line">        <span class="string">"		lea     %a14, [%a14]lo:\\name                \n"</span>\</span><br><span class="line">        <span class="string">"		ji      %a14                                 \n"</span>\</span><br><span class="line">        <span class="string">"	.popsection                                      \n"</span>\</span><br><span class="line">		<span class="string">".endm                                               \n"</span>\</span><br><span class="line">		<span class="string">".macro .int_entry.1 prio,vectabNum,u,name           \n"</span>\</span><br><span class="line">			<span class="string">".int_entry.2 intvec_tc\\vectabNum\\u\\prio,(name) # build the unique name \n"</span>\</span><br><span class="line">		<span class="string">".endm                                               \n"</span>\</span><br><span class="line">        <span class="string">"                                                    \n"</span>\</span><br><span class="line">		<span class="string">".macro .intr.entry name,vectabNum,prio              \n"</span>\</span><br><span class="line">			<span class="string">".int_entry.1 %(prio),%(vectabNum),_,name # evaluate the priority and the cpu number \n"</span>\</span><br><span class="line">		<span class="string">".endm                                               \n"</span>\</span><br><span class="line">		<span class="string">".intr.entry.include:                                \n"</span>\</span><br><span class="line">		<span class="string">".endif                                              \n"</span>\</span><br><span class="line">        <span class="string">".intr.entry "</span>#isr<span class="string">","</span>#vectabNum<span class="string">","</span>#prio               );\</span><br><span class="line">IFX_EXTERN <span class="keyword">void</span> __attribute__ ((interrupt_handler)) isr(); \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isr</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>在Ifx_Irq.h中定义了优先级255的中断响应函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IFX_INTERRUPT_INTERNAL(IfxCpu_Irq_intVecTable, <span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Ifx_CPU_ICR icr;</span><br><span class="line"></span><br><span class="line">    icr.U = __mfcr(CPU_ICR);    <span class="comment">/*Fetch the ICR value */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Call the ISR */</span></span><br><span class="line">    IfxCpu_Irq_swIntVector[icr.B.CCPN]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码展开为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.pushsection .intvec_tc0_255, <span class="string">"ax"</span>, @progbits</span><br><span class="line">__intvec_tc0_255 :</span><br><span class="line">    svlcx</span><br><span class="line">    movh.a  %a14, hi:IfxCpu_Irq_intVecTable</span><br><span class="line">    lea        %a14, [%a14]lo:IfxCpu_Irq_intVecTable</span><br><span class="line">    ji        %a14</span><br><span class="line">.popsection</span><br><span class="line">IFX_EXTERN <span class="keyword">void</span> __attribute__ ((interrupt_handler)) IfxCpu_Irq_intVecTable(); \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IfxCpu_Irq_intVecTable</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Ifx_CPU_ICR icr;</span><br><span class="line"></span><br><span class="line">    icr.U = __mfcr(CPU_ICR);    <span class="comment">/*Fetch the ICR value */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Call the ISR */</span></span><br><span class="line">    IfxCpu_Irq_swIntVector[icr.B.CCPN]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了输入节.__intvec_tc0_255，同时也定义了中断的服务函数。依照优先级255的定义方式即可定义其它优先级的中断服务函数。</p>
<p>最后在启动函数_Core0_start中注册BIV</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__mtcr(CPU_BIV, (uint32)__INTTAB(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>__INTTAB(0)展开为__INTTAB_CPU0。</p>
<p>到此iLLD的硬件中断就实现了。</p>
<h1 id="illd的软件中断实现"><a class="markdownIt-Anchor" href="#illd的软件中断实现"></a> iLLD的软件中断实现</h1>
<p>iLLD的软件中断和硬件中断一样，只是在注册BIV的时候，使用了下面的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Wrapper macros for the tool specific definitions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(IFX_USE_SW_MANAGED_INT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INTTAB(cpu)      ((unsigned int)__INTTAB_CPU##cpu | (unsigned int)0x1FE0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INTTAB(cpu)      __INTTAB_CPU##cpu</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*defined(IFX_USE_SW_MANAGED_INT) */</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到，如果定义了软件中断IFX_USE_SW_MANAGED_INT这个宏，__INTTAB(0)展开就是地址0x800F1FE0,刚好为优先级255的中断向量的地址，没有定义就是0x800F0000，为优先级为0的中断向量地址，也即上面的硬件中断的地址。</p>
<p>软件中断中BIV的值就是0x800F1FE0，根据BIV到中断向量地址的转换公式</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">addr = ( <span class="name">BIV</span> | (<span class="name">ICR</span>.PIPN &lt;&lt; <span class="number">5</span>) )<span class="comment">; //每次入口移动32字节</span></span><br></pre></td></tr></table></figure>
<p>不管优先级是多少，使用0x800F1FE0这个地址进行计算，都得到0x800F1FE0这个地址，即优先级0-255的中断，全都指向优先级255的中断向量，最终都进入了IfxCpu_Irq_intVecTable这个服务函数中，再在这个函数中使用ICR.CCPN优先级分发到不同的服务函数中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IfxCpu_Irq_installInterruptHandler</span><span class="params">(<span class="keyword">void</span> *isrFuncPointer, uint32 serviceReqPrioNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IfxCpu_Irq_swIntVector[serviceReqPrioNumber] = (Ifx_Isr)isrFuncPointer;</span><br><span class="line">&#125;</span><br><span class="line">IFX_INTERRUPT_INTERNAL(IfxCpu_Irq_intVecTable, <span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Ifx_CPU_ICR icr;</span><br><span class="line"></span><br><span class="line">    icr.U = __mfcr(CPU_ICR);    <span class="comment">/*Fetch the ICR value */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Call the ISR */</span></span><br><span class="line">    IfxCpu_Irq_swIntVector[icr.B.CCPN]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，iLLD的软件中断也实现了。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Myklory</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.lnnl.top/2020/04/21/TC275%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1/">http://blog.lnnl.top/2020/04/21/TC275%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.lnnl.top">年年有鱼</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/tricore/">tricore</a><a class="post-meta__tags" href="/tags/TC275/">TC275</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2020/02/18/TC275CPU%E5%AD%90%E7%B3%BB%E7%BB%9F/"><span>TC275CPU子系统</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/ox/wallhaven-oxv8pm.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Myklory</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>